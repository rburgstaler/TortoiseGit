From 5fd3a1871f0b8302be2ce109250cb237f49aab56 Mon Sep 17 00:00:00 2001
From: Patrick Steinhardt <ps@pks.im>
Date: Thu, 17 Sep 2015 11:40:55 +0200
Subject: [PATCH 1006/1024] refdb: rename refdb_fs_backend's .path to .gitpath

The variable '.path' of the refdb_fs_backend struct becomes
confusing regarding the introduction of the git commondir. It
does not immediatly become obvious what it should point to.

Fix this problem by renaming the variable to `gitpath`,
clarifying that it acutally points to the `.git` directory of the
repository, in contrast to the commonpath directory, which points
to the directory containing shared objects like references and
the object store.
---
 src/refdb_fs.c | 61 +++++++++++++++++++++++++++++-----------------------------
 1 file changed, 31 insertions(+), 30 deletions(-)

diff --git a/src/refdb_fs.c b/src/refdb_fs.c
index f978038..647aea6 100644
--- a/src/refdb_fs.c
+++ b/src/refdb_fs.c
@@ -55,7 +55,8 @@ typedef struct refdb_fs_backend {
 	git_refdb_backend parent;
 
 	git_repository *repo;
-	char *path;
+	/* path to git directory */
+	char *gitpath;
 
 	git_sortedcache *refcache;
 	int peeling_mode;
@@ -77,7 +78,7 @@ static int packed_reload(refdb_fs_backend *backend)
 	git_buf packedrefs = GIT_BUF_INIT;
 	char *scan, *eof, *eol;
 
-	if (!backend->path)
+	if (!backend->gitpath)
 		return 0;
 
 	error = git_sortedcache_lockandload(backend->refcache, &packedrefs);
@@ -238,7 +239,7 @@ static int loose_lookup_to_packfile(refdb_fs_backend *backend, const char *name)
 	/* if we fail to load the loose reference, assume someone changed
 	 * the filesystem under us and skip it...
 	 */
-	if (loose_readbuffer(&ref_file, backend->path, name) < 0) {
+	if (loose_readbuffer(&ref_file, backend->gitpath, name) < 0) {
 		giterr_clear();
 		goto done;
 	}
@@ -287,7 +288,7 @@ static int _dirent_loose_load(void *payload, git_buf *full_path)
 		return error;
 	}
 
-	file_path = full_path->ptr + strlen(backend->path);
+	file_path = full_path->ptr + strlen(backend->gitpath);
 
 	return loose_lookup_to_packfile(backend, file_path);
 }
@@ -303,7 +304,7 @@ static int packed_loadloose(refdb_fs_backend *backend)
 	int error;
 	git_buf refs_path = GIT_BUF_INIT;
 
-	if (git_buf_joinpath(&refs_path, backend->path, GIT_REFS_DIR) < 0)
+	if (git_buf_joinpath(&refs_path, backend->gitpath, GIT_REFS_DIR) < 0)
 		return -1;
 
 	/*
@@ -330,7 +331,7 @@ static int refdb_fs_backend__exists(
 	assert(backend);
 
 	if (packed_reload(backend) < 0 ||
-		git_buf_joinpath(&ref_path, backend->path, ref_name) < 0)
+		git_buf_joinpath(&ref_path, backend->gitpath, ref_name) < 0)
 		return -1;
 
 	*exists = git_path_isfile(ref_path.ptr) ||
@@ -372,7 +373,7 @@ static int loose_lookup(
 	if (out)
 		*out = NULL;
 
-	if ((error = loose_readbuffer(&ref_file, backend->path, ref_name)) < 0)
+	if ((error = loose_readbuffer(&ref_file, backend->gitpath, ref_name)) < 0)
 		/* cannot read loose ref file - gah */;
 	else if (git__prefixcmp(git_buf_cstr(&ref_file), GIT_SYMREF) == 0) {
 		const char *target;
@@ -483,12 +484,12 @@ static int iter_load_loose_paths(refdb_fs_backend *backend, refdb_fs_iter *iter)
 	git_iterator_options fsit_opts = GIT_ITERATOR_OPTIONS_INIT;
 	const git_index_entry *entry = NULL;
 
-	if (!backend->path) /* do nothing if no path for loose refs */
+	if (!backend->gitpath) /* do nothing if no gitpath for loose refs */
 		return 0;
 
 	fsit_opts.flags = backend->iterator_flags;
 
-	if ((error = git_buf_printf(&path, "%s/refs", backend->path)) < 0 ||
+	if ((error = git_buf_printf(&path, "%s/refs", backend->gitpath)) < 0 ||
 		(error = git_iterator_for_filesystem(&fsit, path.ptr, &fsit_opts)) < 0) {
 		git_buf_free(&path);
 		return error;
@@ -725,10 +726,10 @@ static int loose_lock(git_filebuf *file, refdb_fs_backend *backend, const char *
 	/* Remove a possibly existing empty directory hierarchy
 	 * which name would collide with the reference name
 	 */
-	if (git_futils_rmdir_r(name, backend->path, GIT_RMDIR_SKIP_NONEMPTY) < 0)
+	if (git_futils_rmdir_r(name, backend->gitpath, GIT_RMDIR_SKIP_NONEMPTY) < 0)
 		return -1;
 
-	if (git_buf_joinpath(&ref_path, backend->path, name) < 0)
+	if (git_buf_joinpath(&ref_path, backend->gitpath, name) < 0)
 		return -1;
 
 	error = git_filebuf_open(file, ref_path.ptr, GIT_FILEBUF_FORCE, GIT_REFS_FILE_MODE);
@@ -912,7 +913,7 @@ static int packed_remove_loose(refdb_fs_backend *backend)
 		if (!ref || !(ref->flags & PACKREF_WAS_LOOSE))
 			continue;
 
-		if (git_buf_joinpath(&full_path, backend->path, ref->name) < 0)
+		if (git_buf_joinpath(&full_path, backend->gitpath, ref->name) < 0)
 			return -1; /* critical; do not try to recover on oom */
 
 		if (git_path_exists(full_path.ptr) && p_unlink(full_path.ptr) < 0) {
@@ -1257,7 +1258,7 @@ static int refdb_fs_backend__delete_tail(
 	}
 
 	/* If a loose reference exists, remove it from the filesystem */
-	if (git_buf_joinpath(&loose_path, backend->path, ref_name) < 0)
+	if (git_buf_joinpath(&loose_path, backend->gitpath, ref_name) < 0)
 		return -1;
 
 	if (git_path_isfile(loose_path.ptr)) {
@@ -1381,20 +1382,20 @@ static void refdb_fs_backend__free(git_refdb_backend *_backend)
 	assert(backend);
 
 	git_sortedcache_free(backend->refcache);
-	git__free(backend->path);
+	git__free(backend->gitpath);
 	git__free(backend);
 }
 
-static int setup_namespace(git_buf *path, git_repository *repo)
+static int setup_namespace(git_buf *gitpath, git_repository *repo)
 {
 	char *parts, *start, *end;
 
-	/* Not all repositories have a path */
+	/* Not all repositories have a gitpath */
 	if (repo->path_repository == NULL)
 		return 0;
 
 	/* Load the path to the repo first */
-	git_buf_puts(path, repo->path_repository);
+	git_buf_puts(gitpath, repo->path_repository);
 
 	/* if the repo is not namespaced, nothing else to do */
 	if (repo->namespace == NULL)
@@ -1411,19 +1412,19 @@ static int setup_namespace(git_buf *path, git_repository *repo)
 	 *  refs under refs/namespaces/foo/refs/namespaces/bar/
 	 */
 	while ((start = git__strsep(&end, "/")) != NULL) {
-		git_buf_printf(path, "refs/namespaces/%s/", start);
+		git_buf_printf(gitpath, "refs/namespaces/%s/", start);
 	}
 
-	git_buf_printf(path, "refs/namespaces/%s/refs", end);
+	git_buf_printf(gitpath, "refs/namespaces/%s/refs", end);
 	git__free(parts);
 
 	/* Make sure that the folder with the namespace exists */
-	if (git_futils_mkdir_relative(git_buf_cstr(path), repo->path_repository,
+	if (git_futils_mkdir_relative(git_buf_cstr(gitpath), repo->path_repository,
 			0777, GIT_MKDIR_PATH, NULL) < 0)
 		return -1;
 
-	/* Return root of the namespaced path, i.e. without the trailing '/refs' */
-	git_buf_rtruncate_at_char(path, '/');
+	/* Return root of the namespaced gitpath, i.e. without the trailing '/refs' */
+	git_buf_rtruncate_at_char(gitpath, '/');
 	return 0;
 }
 
@@ -1920,7 +1921,7 @@ int git_refdb_backend_fs(
 	git_repository *repository)
 {
 	int t = 0;
-	git_buf path = GIT_BUF_INIT;
+	git_buf gitpath = GIT_BUF_INIT;
 	refdb_fs_backend *backend;
 
 	backend = git__calloc(1, sizeof(refdb_fs_backend));
@@ -1928,18 +1929,18 @@ int git_refdb_backend_fs(
 
 	backend->repo = repository;
 
-	if (setup_namespace(&path, repository) < 0)
+	if (setup_namespace(&gitpath, repository) < 0)
 		goto fail;
 
-	backend->path = git_buf_detach(&path);
+	backend->gitpath = git_buf_detach(&gitpath);
 
-	if (git_buf_joinpath(&path, backend->path, GIT_PACKEDREFS_FILE) < 0 ||
+	if (git_buf_joinpath(&gitpath, backend->gitpath, GIT_PACKEDREFS_FILE) < 0 ||
 		git_sortedcache_new(
 			&backend->refcache, offsetof(struct packref, name),
-			NULL, NULL, packref_cmp, git_buf_cstr(&path)) < 0)
+			NULL, NULL, packref_cmp, git_buf_cstr(&gitpath)) < 0)
 		goto fail;
 
-	git_buf_free(&path);
+	git_buf_free(&gitpath);
 
 	if (!git_repository__cvar(&t, backend->repo, GIT_CVAR_IGNORECASE) && t) {
 		backend->iterator_flags |= GIT_ITERATOR_IGNORE_CASE;
@@ -1971,8 +1972,8 @@ int git_refdb_backend_fs(
 	return 0;
 
 fail:
-	git_buf_free(&path);
-	git__free(backend->path);
+	git_buf_free(&gitpath);
+	git__free(backend->gitpath);
 	git__free(backend);
 	return -1;
 }
-- 
2.8.1.windows.1

